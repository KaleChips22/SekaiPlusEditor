type SUSNote = {
  measure: number
  position: number
  totalPositions: number
  lane: number
  width: number
  type: number
  timeScaleGroup?: number
}

const TICKS_PER_BEAT = 480

export const uscToSUS = (
  usc: any,
  options: {
    sideLane?: boolean
    laneOffset?: number
    ticksPerBeat?: number
  } = {},
): string => {
  const sideLane = options.sideLane ?? false
  const laneOffset = options.laneOffset ?? 0
  const ticksPerBeat = options.ticksPerBeat ?? TICKS_PER_BEAT

  const lines: string[] = []
  const bpmMap = new Map<number, string>()
  const bpmLines = new Map<number, Map<number, string>>()
  const tapNotes = new Map<number, Map<number, Map<number, SUSNote>>>()
  const directionalNotes = new Map<number, Map<number, Map<number, SUSNote>>>()
  const slideNotes = new Map<
    string,
    Map<number, Map<number, Map<number, SUSNote>>>
  >()
  const guideNotes = new Map<
    string,
    Map<number, Map<number, Map<number, SUSNote>>>
  >()
  const timeScaleGroups = new Map<
    number,
    { beat: number; timeScale: number }[]
  >()

  let bpmCounter = 1
  const slideCounter = Array.from({ length: 36 }, () => [0])
  const guideCounter = Array.from({ length: 36 }, () => [0])

  lines.push(`generated by SekaiPlusEditor`)
  lines.push(`#ARTIST ""`)
  lines.push(`#DESIGNER ""`)
  lines.push(`#TITLE ""`)
  lines.push(`#WAVEOFFSET ${-usc.offset}`)
  // lines.push(`#BASEBPM 120`)
  lines.push('')
  lines.push(`#REQUEST "ticks_per_beat ${ticksPerBeat}"`)
  lines.push('')
  lines.push('#00002: 4') // 4/4 time requirement
  lines.push('')

  if (sideLane) {
    lines.push(`#REQUEST "side_lane true"`)
    lines.push('')
  }

  if (laneOffset !== 0) {
    lines.push(`#REQUEST "lane_offset ${laneOffset}"`)
    lines.push('')
  }

  for (const obj of usc.objects) {
    if (obj.type === 'bpm') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const bpmId = `${bpmCounter.toString(36).toUpperCase().padStart(2, '0')}`
      bpmMap.set(obj.bpm, bpmId)

      if (!bpmLines.has(measure)) {
        bpmLines.set(measure, new Map())
      }
      const posInMeasure = tick - measure * ticksPerBeat * 4
      bpmLines.get(measure)!.set(posInMeasure, bpmId)
      bpmCounter++
    } else if (obj.type === 'timeScaleGroup') {
      const groupId = 0
      if (!timeScaleGroups.has(groupId)) {
        timeScaleGroups.set(groupId, [])
      }
      timeScaleGroups
        .get(groupId)!
        .push(
          ...obj.changes.map((c: any) => ({
            beat: c.beat,
            timeScale: c.timeScale,
          })),
        )
    }
  }

  for (const [bpm, bpmId] of bpmMap) {
    lines.push(`#BPM${bpmId}: ${bpm}`)
  }
  lines.push('')

  for (const [groupId, changes] of timeScaleGroups) {
    const groupIdStr = groupId.toString(36).toUpperCase().padStart(2, '0')
    const changesStr = changes
      .map((c) => {
        const tick = Math.round(c.beat * ticksPerBeat)
        const measure = Math.floor(tick / ticksPerBeat / 4)
        const tickInMeasure = tick - measure * ticksPerBeat * 4
        return `${measure}'${tickInMeasure}:${c.timeScale}`
      })
      .join(',')
    lines.push(`#TIL${groupIdStr}: "${changesStr}"`)
    lines.push(`#HISPEED ${groupIdStr}`)
  }
  lines.push('')

  for (const obj of usc.objects) {
    if (obj.type === 'single') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const posInMeasure = tick - measure * ticksPerBeat * 4

      const uscLane = obj.lane - laneOffset
      const susLane = Math.round(uscLane + 8 - obj.size)
      const width = Math.round(obj.size * 2)

      let noteType = 1
      if (obj.critical && obj.trace) {
        noteType = 6
      } else if (obj.trace) {
        noteType = 5
      } else if (obj.critical) {
        noteType = 2
      }

      addNote(tapNotes, measure, susLane, posInMeasure, {
        measure,
        position: posInMeasure,
        totalPositions: ticksPerBeat * 4,
        lane: susLane,
        width,
        type: noteType,
        timeScaleGroup: obj.timeScaleGroup,
      })

      if (obj.direction) {
        let dirType = 1
        if (obj.direction === 'left') {
          dirType = 3
        } else if (obj.direction === 'right') {
          dirType = 4
        }

        addNote(directionalNotes, measure, susLane, posInMeasure, {
          measure,
          position: posInMeasure,
          totalPositions: ticksPerBeat * 4,
          lane: susLane,
          width,
          type: dirType,
          timeScaleGroup: obj.timeScaleGroup,
        })
      }
    } else if (obj.type === 'damage') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const posInMeasure = tick - measure * ticksPerBeat * 4

      const uscLane = obj.lane - laneOffset
      const susLane = Math.round(uscLane + 8 - obj.size)
      const width = Math.round(obj.size * 2)

      addNote(tapNotes, measure, susLane, posInMeasure, {
        measure,
        position: posInMeasure,
        totalPositions: ticksPerBeat * 4,
        lane: susLane,
        width,
        type: 4,
        timeScaleGroup: obj.timeScaleGroup,
      })
    } else if (obj.type === 'skill') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const posInMeasure = tick - measure * ticksPerBeat * 4

      addNote(tapNotes, measure, 0, posInMeasure, {
        measure,
        position: posInMeasure,
        totalPositions: ticksPerBeat * 4,
        lane: 0,
        width: 2,
        type: 4,
      })
    } else if (obj.type === 'feverChance') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const posInMeasure = tick - measure * ticksPerBeat * 4

      addNote(tapNotes, measure, 15, posInMeasure, {
        measure,
        position: posInMeasure,
        totalPositions: ticksPerBeat * 4,
        lane: 15,
        width: 2,
        type: 1,
      })
    } else if (obj.type === 'feverStart') {
      const tick = Math.round(obj.beat * ticksPerBeat)
      const measure = Math.floor(tick / ticksPerBeat / 4)
      const posInMeasure = tick - measure * ticksPerBeat * 4

      addNote(tapNotes, measure, 15, posInMeasure, {
        measure,
        position: posInMeasure,
        totalPositions: ticksPerBeat * 4,
        lane: 15,
        width: 2,
        type: 2,
      })
    } else if (obj.type === 'slide') {
      const index = slideCounter.findIndex(
        (x) =>
          x[x.length - 1] <
          obj.connections.find((n: any) => n.type === 'start').beat,
      )
      if (index === -1) {
        throw new Error('Too many slides')
      }
      const slideId = index.toString(36).toUpperCase()
      slideCounter.push(
        obj.connections.find((n: any) => n.type === 'start').beat,
        obj.connections.find((n: any) => n.type === 'end').beat,
      )

      for (let i = 0; i < obj.connections.length; i++) {
        const conn = obj.connections[i]
        const tick = Math.round(conn.beat * ticksPerBeat)
        const measure = Math.floor(tick / ticksPerBeat / 4)
        const posInMeasure = tick - measure * ticksPerBeat * 4

        const uscLane = conn.lane - laneOffset
        const susLane = Math.round(uscLane + 8 - conn.size)
        const width = Math.round(conn.size * 2)

        let noteType = 3
        const isAttach = 'attach' in conn && conn.attach
        if (isAttach) {
          noteType = 3

          addNote(tapNotes, measure, susLane, posInMeasure, {
            measure,
            position: posInMeasure,
            totalPositions: ticksPerBeat * 4,
            lane: susLane,
            width,
            type: obj.critical ? 8 : 7,
            timeScaleGroup: conn.timeScaleGroup,
          })
        } else {
          if (conn.type === 'start') {
            noteType = 1
          } else if (conn.type === 'end') {
            noteType = 2
          } else if (conn.type === 'tick') {
            noteType = 5

            if ('critical' in conn) noteType = 3
          }
          if ('judgeType' in conn && conn.judgeType === 'none') {
            addNote(tapNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type: obj.critical ? 8 : 7,
              timeScaleGroup: conn.timeScaleGroup,
            })
          } else if ('judgeType' in conn && conn.judgeType === 'trace') {
            addNote(tapNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type: 5,
              timeScaleGroup: conn.timeScaleGroup,
            })
          }

          if (conn.type === 'start' && obj.critical) {
            addNote(tapNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type:
                conn.judgeType === 'trace'
                  ? 6
                  : conn.judgeType === 'none'
                    ? 8
                    : 2,
              timeScaleGroup: conn.timeScaleGroup,
            })
          }

          if ('ease' in conn && conn.ease) {
            if (conn.ease === 'in') {
              addNote(directionalNotes, measure, susLane, posInMeasure, {
                measure,
                position: posInMeasure,
                totalPositions: ticksPerBeat * 4,
                lane: susLane,
                width,
                type: 2,
                timeScaleGroup: conn.timeScaleGroup,
              })
            } else if (conn.ease === 'out') {
              addNote(directionalNotes, measure, susLane, posInMeasure, {
                measure,
                position: posInMeasure,
                totalPositions: ticksPerBeat * 4,
                lane: susLane,
                width,
                type: 5,
                timeScaleGroup: conn.timeScaleGroup,
              })
            }
          }

          if (conn.type === 'end' && 'direction' in conn && conn.direction) {
            let dirType = 1
            if (conn.direction === 'left') {
              dirType = 3
            } else if (conn.direction === 'right') {
              dirType = 4
            }

            addNote(directionalNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type: dirType,
              timeScaleGroup: conn.timeScaleGroup,
            })
          }
        }

        addNote(
          slideNotes.get(slideId) || createSlideMap(slideNotes, slideId),
          measure,
          susLane,
          posInMeasure,
          {
            measure,
            position: posInMeasure,
            totalPositions: ticksPerBeat * 4,
            lane: susLane,
            width,
            type: noteType,
            timeScaleGroup: conn.timeScaleGroup,
          },
        )
      }
    } else if (obj.type === 'guide') {
      const connKey = 'midpoints' in obj ? 'midpoints' : 'connections'
      const index = guideCounter.findIndex(
        (x) =>
          x[x.length - 1] <
          obj[connKey].sort((a: any, b: any) => a.beat - b.beat)[0].beat,
      )
      if (index === -1) {
        throw new Error('Too many slides')
      }
      const guideId = index.toString(36).toUpperCase()
      guideCounter.push(
        obj[connKey].sort((a: any, b: any) => a.beat - b.beat)[0].beat,
        obj[connKey].sort((a: any, b: any) => b.beat - a.beat)[0].beat,
      )

      for (const conn of obj[connKey]) {
        const tick = Math.round(conn.beat * ticksPerBeat)
        const measure = Math.floor(tick / ticksPerBeat / 4)
        const posInMeasure = tick - measure * ticksPerBeat * 4

        const uscLane = conn.lane - laneOffset
        const susLane = Math.round(uscLane + 8 - conn.size)
        const width = Math.round(conn.size * 2)

        let noteType = 1
        if (conn.type === 'start') {
          noteType = 1
        } else if (conn.type === 'end') {
          noteType = 2
        } else if (conn.type === 'tick') {
          noteType = 5
        }

        if (obj.color === 'yellow') {
          addNote(tapNotes, measure, susLane, posInMeasure, {
            measure,
            position: posInMeasure,
            totalPositions: ticksPerBeat * 4,
            lane: susLane,
            width,
            type: 8,
            timeScaleGroup: conn.timeScaleGroup,
          })
        }

        if ('ease' in conn && conn.ease) {
          if (conn.ease === 'in') {
            addNote(directionalNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type: 2,
              timeScaleGroup: conn.timeScaleGroup,
            })
          } else if (conn.ease === 'out') {
            addNote(directionalNotes, measure, susLane, posInMeasure, {
              measure,
              position: posInMeasure,
              totalPositions: ticksPerBeat * 4,
              lane: susLane,
              width,
              type: 5,
              timeScaleGroup: conn.timeScaleGroup,
            })
          }
        }

        addNote(
          guideNotes.get(guideId) || createSlideMap(guideNotes, guideId),
          measure,
          susLane,
          posInMeasure,
          {
            measure,
            position: posInMeasure,
            totalPositions: ticksPerBeat * 4,
            lane: susLane,
            width,
            type: noteType,
            timeScaleGroup: conn.timeScaleGroup,
          },
        )
      }
    }
  }

  const allMeasures = new Set<number>()

  for (const measure of bpmLines.keys()) allMeasures.add(measure)
  for (const measure of tapNotes.keys()) allMeasures.add(measure)
  for (const measure of directionalNotes.keys()) allMeasures.add(measure)
  for (const slideMap of slideNotes.values()) {
    for (const measure of slideMap.keys()) allMeasures.add(measure)
  }
  for (const guideMap of guideNotes.values()) {
    for (const measure of guideMap.keys()) allMeasures.add(measure)
  }

  const sortedMeasures = Array.from(allMeasures).sort((a, b) => a - b)

  for (const measure of sortedMeasures) {
    if (bpmLines.has(measure)) {
      const positions = bpmLines.get(measure)!
      const line = generateLine(
        measure,
        '08',
        positions,
        ticksPerBeat * 4,
        (bpmId) => bpmId,
      )
      if (line) lines.push(line)
    }

    if (tapNotes.has(measure)) {
      const lanes = tapNotes.get(measure)!
      for (const [lane, positions] of lanes) {
        const laneHex = lane.toString(36).toUpperCase()
        const line = generateNoteLine(
          measure,
          `1${laneHex}`,
          positions,
          ticksPerBeat * 4,
        )
        if (line) lines.push(line)
      }
    }

    if (directionalNotes.has(measure)) {
      const lanes = directionalNotes.get(measure)!
      for (const [lane, positions] of lanes) {
        const laneHex = lane.toString(36).toUpperCase()
        const line = generateNoteLine(
          measure,
          `5${laneHex}`,
          positions,
          ticksPerBeat * 4,
        )
        if (line) lines.push(line)
      }
    }
  }

  for (const [slideId, slideMap] of slideNotes) {
    for (const measure of sortedMeasures) {
      if (!slideMap.has(measure)) continue

      const lanes = slideMap.get(measure)!
      for (const [lane, positions] of lanes) {
        const laneHex = lane.toString(36).toUpperCase()
        const line = generateNoteLine(
          measure,
          `3${laneHex}${slideId}`,
          positions,
          ticksPerBeat * 4,
        )
        if (line) lines.push(line)
      }
    }
  }

  for (const [guideId, guideMap] of guideNotes) {
    for (const measure of sortedMeasures) {
      if (!guideMap.has(measure)) continue

      const lanes = guideMap.get(measure)!
      for (const [lane, positions] of lanes) {
        const laneHex = lane.toString(36).toUpperCase()
        const line = generateNoteLine(
          measure,
          `9${laneHex}${guideId}`,
          positions,
          ticksPerBeat * 4,
        )
        if (line) lines.push(line)
      }
    }
  }

  return lines.join('\n')
}

function createSlideMap(
  slideNotes: Map<string, Map<number, Map<number, Map<number, SUSNote>>>>,
  slideId: string,
) {
  const map = new Map<number, Map<number, Map<number, SUSNote>>>()
  slideNotes.set(slideId, map)
  return map
}

function addNote(
  map: Map<number, Map<number, Map<number, SUSNote>>>,
  measure: number,
  lane: number,
  position: number,
  note: SUSNote,
) {
  if (!map.has(measure)) {
    map.set(measure, new Map())
  }
  if (!map.get(measure)!.has(lane)) {
    map.get(measure)!.set(lane, new Map())
  }
  map.get(measure)!.get(lane)!.set(position, note)
}

function generateLine(
  measure: number,
  suffix: string,
  positions: Map<number, string>,
  totalPositions: number,
  valueGetter: (value: string) => string,
): string | null {
  if (positions.size === 0) return null

  const gcd = findGCD(Array.from(positions.keys()).concat([totalPositions]))
  const resolution = totalPositions / gcd

  const data: string[] = []
  for (let i = 0; i < resolution; i++) {
    const pos = (i * totalPositions) / resolution
    const value = positions.get(pos)
    data.push(value ? valueGetter(value) : '00')
  }

  const measureStr = measure.toString().padStart(3, '0')
  return `#${measureStr}${suffix}: ${data.join('')}`
}

function generateNoteLine(
  measure: number,
  suffix: string,
  positions: Map<number, SUSNote>,
  totalPositions: number,
): string | null {
  if (positions.size === 0) return null

  const gcd = findGCD(Array.from(positions.keys()).concat([totalPositions]))
  const resolution = totalPositions / gcd

  const data: string[] = []
  for (let i = 0; i < resolution; i++) {
    const pos = (i * totalPositions) / resolution
    const note = positions.get(pos)
    if (note) {
      const typeHex = note.type.toString(36).toUpperCase()
      const widthHex = note.width.toString(36).toUpperCase()
      data.push(`${typeHex}${widthHex}`)
    } else {
      data.push('00')
    }
  }

  const measureStr = measure.toString().padStart(3, '0')
  return `#${measureStr}${suffix}: ${data.join('')}`
}

function findGCD(numbers: number[]): number {
  const gcd2 = (a: number, b: number): number => {
    a = Math.round(a)
    b = Math.round(b)
    return b === 0 ? a : gcd2(b, a % b)
  }

  return numbers.reduce((a, b) => gcd2(a, b))
}
